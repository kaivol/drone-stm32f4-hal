use core::marker::PhantomData;

pub trait Freq {
    fn freq(self) -> u32;
}

/// The High-Speed External (HSE) clock.
#[derive(Copy, Clone)]
pub struct HseClk(u32);

impl Freq for HseClk {
    fn freq(self) -> u32 {
        self.0
    }
}

/// The High-Speed Internal (HSI) 16MHz clock.
#[derive(Copy, Clone)]
pub struct HsiClk;

impl Freq for HsiClk {
    fn freq(self) -> u32 {
        16_000_000
    }
}

/// The pll clock source.
#[derive(Copy, Clone)]
pub enum PllSrcMux {
    Hsi(HsiClk),
    Hse(HseClk),
}

impl PllSrcMux {
    pub const fn to_pllsrc(self, pll_m: u32) -> PllSrc {
        PllSrc {
            mux: self,
            m: pll_m,
        }
    }
}

impl Freq for PllSrcMux {
    fn freq(self) -> u32 {
        match self {
            PllSrcMux::Hsi(clk) => clk.freq(),
            PllSrcMux::Hse(clk) => clk.freq(),
        }
    }
}

/// The pll input clock (vcoin).
#[derive(Copy, Clone)]
pub struct PllSrc {
    /// The pll input clock source.
    pub mux: PllSrcMux,
    /// Pll source clock input division factor.
    /// vcoin = src / m
    pub m: u32,
}


impl PllSrc {
    pub const fn to_pll(self, pll_n: u32, pll_p: u32, pll_q: u32) -> Pll {
        let vco = PllVco { src: self, n: pll_n };
        Pll {
            vco,
            p: PllClk { _out: PhantomData, src: vco, div: pll_p },
            q: PllClk { _out: PhantomData, src: vco, div: pll_q },
        }
    }
}

impl Freq for PllSrc {
    fn freq(self) -> u32 {
        self.mux.freq() / self.m
    }
}

/// The clocks generated by the pll.
/// pllp: pllclk = vcoin * n / p
/// pllq: vcoin * n / q
#[derive(Copy, Clone)]
pub struct PllVco {
    /// The pll input clock signal (vcoin).
    pub src: PllSrc,
    /// Pll multiplication factor for vco.
    /// vccout = vcoin * n
    pub n: u32,
}

impl Freq for PllVco {
    fn freq(self) -> u32 {
        (self.src.freq() / self.src.m) * self.n
    }
}

#[derive(Copy, Clone)]
pub struct PllP;
#[derive(Copy, Clone)]
pub struct PllQ;

/// A pll generated clock, e.g. PllClk<PllP> = vcoin * n / p
#[derive(Copy, Clone)]
pub struct PllClk<Out> {
    _out: PhantomData<Out>,
    src: PllVco,
    div: u32,
}

impl<Out> Freq for PllClk<Out> {
    fn freq(self) -> u32 {
        self.src.freq() / self.div
    }
}

pub struct Pll {
    pub vco: PllVco,
    /// Pll division factor for system clock.
    pub p: PllClk<PllP>,
    /// Pll division factor for usb, sdio, and rng.
    pub q: PllClk<PllQ>,
}

/// The system clock source.
#[derive(Copy, Clone)]
pub enum SysClkMux {
    Hsi(HsiClk),
    Hse(HseClk),
    Pll(PllClk<PllP>),
}

impl SysClkMux {
    pub const fn to_hclk(self, hpre: u32) -> HClk {
        HClk {
            mux: self,
            hpre,
        }
    }
}

impl Freq for SysClkMux {
    fn freq(self) -> u32 {
        match self {
            SysClkMux::Hsi(clk) => clk.freq(),
            SysClkMux::Hse(clk) => clk.freq(),
            SysClkMux::Pll(clk) => clk.freq(),
        }
    }
}

/// The AHB (Advanced High-Performance Bus) and CPU clock.
#[derive(Copy, Clone)]
pub struct HClk {
    /// The clock source.
    mux: SysClkMux,
    /// The clock prescaler.
    /// hclk = sysclk / hpre
    hpre: u32,
}

impl HClk {
    pub const fn to_pclk1(self, ppre1: u32) -> PClk1 {
        PClk1 {
            src: self,
            ppre1,
        }
    }

    pub const fn to_pclk2(self, ppre2: u32) -> PClk2 {
        PClk2 {
            src: self,
            ppre2,
        }
    }
}

impl Freq for HClk {
    fn freq(self) -> u32 {
        self.mux.freq() / self.hpre
    }
}

/// The APB1 (Low Speed Advanced Peripheral Bus) peripheral clock.
#[derive(Copy, Clone)]
pub struct PClk1 {
    /// The clock source.
    src: HClk,
    /// The clock prescaler.
    /// pclk1 = hclk / ppre1
    ppre1: u32,
}

impl Freq for PClk1 {
    fn freq(self) -> u32 {
        self.src.freq() / self.ppre1
    }
}

/// The APB2 (High Speed Advanced Peripheral Bus) peripheral clock.
#[derive(Copy, Clone)]
pub struct PClk2 {
    src: HClk,
    /// The clock prescaler.
    /// pclk2 = hclk / ppre2
    ppre2: u32,
}

impl Freq for PClk2 {
    fn freq(self) -> u32 {
        self.src.freq() / self.ppre2
    }
}

const HSE_CLK: HseClk = HseClk(8_000_000);
const PLL_SRC: PllSrc = PllSrcMux::Hse(HSE_CLK).to_pllsrc(1);
const PLL: Pll = PLL_SRC.to_pll(100, 10, 2);
const HCLK: HClk = SysClkMux::Pll(PLL.p).to_hclk(1);
const PCLK1: PClk1 = HCLK.to_pclk1(1);
const PCLK2: PClk2 = HCLK.to_pclk2(1);