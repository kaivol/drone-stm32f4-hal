use drone_cortexm::{fib, reg::prelude::*, thr::prelude::*};
// use drone_stm32_map::periph::rcc::{RccPeriph};
use drone_stm32_map::reg;

pub struct RccSetup<RccInt: IntToken> {
    /// The clock control register.
    pub rcc_cr: reg::rcc::Cr<Srt>,
    /// The PLL configuration register.
    pub rcc_pllcfgr: reg::rcc::Pllcfgr<Srt>,
    /// The clock configuration register.
    pub rcc_cfgr: reg::rcc::Cfgr<Srt>,
    /// The clock interrupt register.
    pub rcc_cir: reg::rcc::Cir<Srt>,

    pub flash_acr: reg::flash::Acr<Srt>,
    pub pwr_cr: reg::pwr::Cr<Srt>,
    pub pwr_csr: reg::pwr::Csr<Srt>,
    pub thr_rcc: RccInt,
}

/// Built-in high speed clock frequency.
pub const HSI: u32 = 16_000_000; // Hz

/// System clock frequency.
pub const SYS_CLK: u32 = 180_000_000;
pub const USE_OVERDRIVE: bool = true;
// Use 5 wait states as flash latetency for 150MHz < HCLK <= 180 MHz @ 3.6V operation (see RM0090 table 11, page 81)
pub const FLASH_LATENCY: u32 = 5;

impl<RccInt: IntToken> RccSetup<RccInt> {
    pub async fn apply(self) {
        let RccSetup { rcc_cir, .. } = self;

        // Raise the frequency to 180 MHz
        // To enter Over-drive mode, follow the sequence below (see RM0090 page 123):
        // 1. Select HSI or HSE as system clock.
        // 2. Configure RCC_PLLCFGR register and set PLLON bit of RCC_CR register.
        // 3. Set ODEN bit of PWR_CR register to enable the Over-drive mode and wait for the ODRDY flag to be set in the PWR_CSR register.
        // 4. Set the ODSW bit in the PWR_CR register to switch the voltage regulator from Normal mode to Over-drive mode.
        //    The System will be stalled during the switch but the PLL clock system will be still running during locking phase.
        // 5. Wait for the ODSWRDY flag in the PWR_CSR to be set.
        // 6. Select the required Flash latency as well as AHB and APB prescalers.
        // 7. Wait for PLL lock.
        // 8. Switch the system clock to the PLL.
        // 9. Enable the peripherals that are not generated by the System PLL (I2S clock, LCD-TFT clock, SAI1 clock, USB_48MHz clock....).
    
        // Enable HSERDY (high speed oscillator, ready) and PLLRDY (PLL, ready) interrupts
        rcc_cir.modify(|r| r.set_hserdyie().set_pllrdyie());
    
    
        // 1. Select HSI or HSE as system clock.
        // We need to move ownership of `hserdyc` and `hserdyf` into the fiber.
        let reg::rcc::Cir {
            hserdyc, hserdyf, ..
        } = rcc_cir;
        // Attach a listener that will notify us when RCC_CIR->HSERDYF is asserted.
        let hserdy = self.thr_rcc.add_future(fib::new_fn(move || {
            // Is HSERDY flag set?
            if hserdyf.read_bit() {
                // Clear HSERDYF by setting HSERDYC (HSERDY Clear)
                hserdyc.set_bit();
                fib::Complete(())
            } else {
                fib::Yielded(())
            }
        }));
        // Enable the HSE clock.
        self.rcc_cr.modify(|r| r.set_hseon());
        // Sleep until RCC_CIR_HSERDYF is asserted.
        hserdy.await;
    
    
        // 2. Configure RCC_PLLCFGR register and set PLLON bit of RCC_CR register.
        // We need to move ownership of `pllrdyc` and `pllrdyf` into the fiber.
        let reg::rcc::Cir {
            pllrdyc, pllrdyf, ..
        } = rcc_cir;
        // Attach a listener that will notify us when RCC_CIR_PLLRDYF is asserted.
        let pllrdy = self.thr_rcc.add_future(fib::new_fn(move || {
            // Is PLLRDY flag set?
            if pllrdyf.read_bit() {
                // Clear PLLRDYF by setting PLLRDYC (PLLRDY Clear)
                pllrdyc.set_bit();
                fib::Complete(())
            } else {
                fib::Yielded(())
            }
        }));
        // Configure the PLL.
        self.rcc_pllcfgr.modify(|r| { r
            .write_pllq(8)     // Main PLL (PLL) division factor for USB OTG FS, SDIO and random number generator clocks, 8: /8.
            .set_pllsrc()      // Use HSE oscillator clock selected as PLL input clock.
            .write_pllp(0)     // Main PLL division factor for system clock, 0: /2.
            .write_plln(360/2) // Main multiplication factor for VCO, 180: 360.
            .write_pllm(8)     // Main PLL division factor for input clock, 8: /8.
        });
        // Enable the PLL.
        self.rcc_cr.modify(|r| r.set_pllon());
        
        if USE_OVERDRIVE {
            // 3. Set ODEN bit of PWR_CR register to enable the Over-drive mode and wait for the ODRDY flag to be set in the PWR_CSR register.
            self.pwr_cr.modify(|r| r.set_oden());
            loop {
                if self.pwr_csr.odrdy.read_bit() {
                    break;
                }
            }
    
    
            // 4. Set the ODSW bit in the PWR_CR register to switch the voltage regulator from Normal mode to Over-drive mode.
            //    The System will be stalled during the switch but the PLL clock system will be still running during locking phase.
            self.pwr_cr.modify(|r| r.set_odswen());
    
    
            // 5. Wait for the ODSWRDY flag in the PWR_CSR to be set.
            loop {
                if self.pwr_csr.odswrdy.read_bit() {
                    break;
                }
            }
        }
    
    
        // 6. Select the required Flash latency as well as AHB and APB prescalers.
        self.flash_acr.modify(|r| r.write_latency(FLASH_LATENCY));
    
    
        // 7. Wait for PLL lock.
        // Sleep until RCC_CIR_PLLRDYF is asserted.
        pllrdy.await;
    
        // 8. Switch the system clock to the PLL.
        self.rcc_cfgr.modify(|r| r.write_sw(0b10));
    }
}